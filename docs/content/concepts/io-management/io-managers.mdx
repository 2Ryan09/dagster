---
title: IO Managers | Dagster
description: IO Managers determine how to store assets and op outputs and load asset and op inputs.
---

# IO Managers

IO Managers are user-provided objects that store op outputs and assets and load them as inputs to downstream ops and assets.

<Image
alt="IO Manager Diagram"
src="/images/io-managers.png"
width={3200}
height={1040}
/>

## Relevant APIs

| Name                                                        | Description                                                                                                                                                                                                 |
| ----------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <PyObject module="dagster" object="io_manager" decorator /> | A decorator used to define IO managers.                                                                                                                                                                     |
| <PyObject module="dagster" object="IOManager" />            | Base class for user-provided IO managers.                                                                                                                                                                   |
| <PyObject object="build_input_context"/>                    | Function for directly constructing a <PyObject object="InputContext"/>, to be passed to the <PyObject object="IOManager" method="load_input"/> method. This is designed primarily for testing purposes.     |
| <PyObject object="build_output_context"/>                   | Function for directly constructing a <PyObject object="OutputContext"/>, to be passed to the <PyObject object="IOManager" method="handle_output"/> method. This is designed primarily for testing purposes. |

## Overview

Dagster ops and software-defined assets often have parameters and return values. This allows coding in a "functional" style: the function decorated by `@op` or `@asset` is only responsible for business logic, and separate code handles the IO - loading the input values and storing the return values.

This separate code lives inside an <PyObject module="dagster" object="IOManager" />. <PyObject module="dagster" object="IOManager" pluralize /> are user-provided objects that are responsible for storing the output of an op or asset and loading it as input to downstream ops or assets. For example, an IO manager might store objects in files on a filesystem or tables in a database.

Not all op inputs depend on upstream outputs. The [Unconnected Inputs](/concepts/io-management/unconnected-inputs) overview covers <PyObject module="dagster" object="DagsterTypeLoader" pluralize /> and <PyObject module="dagster" object="RootInputManager" displayText="RootInputManagers (experimental)" />, which let you decide how non-asset inputs at the beginning of a job are loaded.

### Outputs and downstream inputs

Each op output and software-defined asset can have its own IO manager, or multiple op outputs and software-defined assets can share an IO manager. The IO manager that's used for handling a particular op output or software-defined asset is automatically used for loading it in downstream ops and software-defined assets.

<Image
alt="two-io-managers"
src="/images/concepts/two-io-managers.png"
width={3200}
height={1040}
/>

<!-- https://excalidraw.com/#json=4546514944786432,52cpcHHoWfzOMro2eFC6MQ -->

This diagram shows a job with two IO managers, each of which is shared across a few inputs and outputs.

The default IO manager, <PyObject module="dagster" object="fs_io_manager" />, pickles values and stores them on the local filesystem. If a job is invoked via <PyObject object="JobDefinition" method="execute_in_process" />, the default IO manager is switched to <PyObject module="dagster" object="mem_io_manager"/>, which stores outputs in memory. Dagster provides out-of-the-box IOManagers that pickle objects and save them in the object stores from the major Cloud providers. These are <PyObject module="dagster_aws.s3" object="s3_pickle_io_manager"/> , <PyObject module="dagster_azure.adls2" object="adls2_pickle_io_manager"/> , or <PyObject module="dagster_gcp.gcs" object="gcs_pickle_io_manager"/>.

IOManagers are [resources](/concepts/resources), which means users can supply different IOManagers for the same op outputs in different situations. For example, you might use an in-memory IO manager for unit-testing a job and an S3IOManager in production.

---

## Specifying IO managers for software-defined assets

### The default IO manager

The default IO manager materializes assets by pickling them to local files with the name of the asset.

### Asset IO manager

You can override the default IO manager at the asset level by specifying an <PyObject object="IOManagerDefinition" /> when defining the asset. For example, this snippet instructs Dagster to store the asset in an object on [S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html), keyed by the name of the asset:

```python
from dagster import asset
from dagster_aws.s3 import s3_pickle_io_manager


@asset(io_manager_def=s3_pickle_io_manager)
def my_asset():
    return ...
```

### Late-binding IO managers

Sometimes you want the same asset to be stored using different IO managers in different environments. For example, in a local dev environment, you might want to store objects on your local filesystem, while in production, you might want to instead store them on S3. _IO manager keys_ offer a layer of indirection that allows specifying the <PyObject object="IOManagerDefinition" /> after you've already constructed an asset op. The default `io_manager_key` for every asset is `"io_manager"`.

```python
from dagster import asset, fs_io_manager, repository
from dagster_aws.s3 import s3_pickle_io_manager

@asset
def my_asset():
    return ...

@repository
def dev():
    return [my_asset, {"io_manager": fs_io_manager}]

@repository
def prod():
    return [my_asset, {"io_manager": s3_pickle_io_manager}]
```

If you want the IO managers to depend on the environment and you also want different assets to use different IO managers, you can set different IO manager keys on different assets:

```python
from dagster import asset, fs_io_manager, repository
from dagster_aws.s3 import s3_pickle_io_manager
from my_lib import snowflake_io_manager, mock_snowflake_io_manager

@asset(io_manager_key="warehouse")
def my_table_asset():
    return ...

@asset(io_manager_key="object_store")
def my_object_asset():
    return ...

assets = [my_table_asset, my_object_asset]

@repository
def dev():
    return [*assets, {"warehouse": mock_snowflake_io_manager, "object_store": fs_io_manager}]

@repository
def prod():
    return [*assets, {"warehouse": snowflake_io_manager, "object_store": s3_pickle_io_manager}]
```


## Specifying IO managers for op outputs

### Op output IO manager

You can override the default IO manager for an op output when defining the op. For example, this snippet instructs Dagster to store the op output in an object on [S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html), keyed by the name of the op and the name of the output (which defaults to "result"):

```python
from dagster import Out, op
from dagster_aws.s3 import s3_pickle_io_manager


@op(out=Out(io_manager_def=s3_pickle_io_manager))
def my_op():
    return ...
```

### Late-binding IO managers

Sometimes you want the same op output to be stored using different IO managers in different environments. For example, in a local dev environment, you might want to store objects on your local filesystem, while in production, you might want to instead store them on S3. _IO manager keys_ offer a layer of indirection that allows specifying the <PyObject object="IOManagerDefinition" /> after you've already constructed an op. The default `io_manager_key` for every asset is `"io_manager"`.

```python file=/concepts/io_management/default_io_manager.py
from dagster import fs_io_manager, job, op


@op
def op_1():
    return 1


@op
def op_2(a):
    return a + 1


@job(resource_defs={"io_manager": fs_io_manager})
def my_job():
    op_2(op_1())
```

If you want the IO managers to depend on the environment and you also want different assets to use different IO managers, you can set different IO manager keys on different op outputs:

```python file=/concepts/io_management/io_manager_per_output.py startafter=start_marker endbefore=end_marker
from dagster_aws.s3 import s3_pickle_io_manager, s3_resource

from dagster import Out, fs_io_manager, job, op


@op(out=Out(io_manager_key="fs"))
def op_1():
    return 1


@op(out=Out(io_manager_key="s3_io"))
def op_2(a):
    return a + 1


@job(
    resource_defs={
        "fs": fs_io_manager,
        "s3_io": s3_pickle_io_manager,
        "s3": s3_resource,
    }
)
def my_job():
    op_2(op_1())
```
