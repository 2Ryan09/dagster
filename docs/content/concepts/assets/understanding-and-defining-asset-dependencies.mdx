---
title: "Understanding and defining asset dependencies | Dagster Docs"
---

# Understanding and defining asset dependencies

\[INTRO]

---

## Dependency types

- Comparison of the different dependency types
- Description of what it is
- Include example uses and when to use each one
- Subsections will discuss and demonstrate how to define each type of dependency

| Type                       | Description | Example uses |   |
| -------------------------- | ----------- | ------------ | - |
| Basic                      |             |              |   |
| Managed-loading (basic)    |             |              |   |
| Managed-loading (explicit) |             |              |   |
| External                   |             |              |   |

---

## Basic asset dependencies

You can define a dependency between two assets by passing the upstream asset to the `deps` parameter in the downstream asset's `@asset` decorator.

In this example, the asset `sugary_cereals` creates a new table (`sugary_cereals`) by selecting records from the `cereals` table. Then the asset `shopping_list` creates a new table (`shopping_list`) by selecting records from `sugary_cereals`:

<TabGroup>
<TabItem name="Asset definition">

Click the **Asset in the Dagster UI** tab to see how this asset would be rendered in the Dagster UI.

```python file=/concepts/assets/non_argument_deps.py startafter=start_marker endbefore=end_marker
from dagster import asset


@asset
def sugary_cereals() -> None:
    execute_query("CREATE TABLE sugary_cereals AS SELECT * FROM cereals")


@asset(deps=[sugary_cereals])
def shopping_list() -> None:
    execute_query("CREATE TABLE shopping_list AS SELECT * FROM sugary_cereals")
```

---

</TabItem>
<TabItem name="Asset in the Dagster UI">

Click the **Asset definition** tab to view how this asset is defined.

TODO: Only for tab demonstration; will replace.

<Image
alt="The files_in_s3 external asset in the Asset Graph of the Dagster UI"
src="/images/concepts/assets/external-asset.png"
width={3024}
height={1654}
/>

---

</TabItem>
</TabGroup>

## Managed-loading dependencies

<!-- TODO - what is a "managed-loading" dependency? -->

### Basic

When using basic dependencies, as above, it's expected that if you need direct access to the contents of the asset, the code you include inside your `@asset`-decorated function will load the data from the upstream asset. Dagster alternatively allows you to delegate loading data to an [I/O manager](/concepts/io-management/io-managers). To do this, you express the dependency by using the upstream asset name as the name of one of the arguments on the decorated function.

In the following example, `downstream_asset` depends on `upstream_asset`. That means that the contents of `upstream_asset` are provided to the function that computes the contents of `downstream_asset`.

```python file=/concepts/assets/asset_dependency.py startafter=start_marker endbefore=end_marker
@asset
def upstream_asset():
    return [1, 2, 3]


@asset
def downstream_asset(upstream_asset):
    return upstream_asset + [4]
```

In this example, Dagster will load the data returned from `upstream_asset` and pass it as the `upstream_asset` parameter to `downstream_asset`.

### Explicit

If defining dependencies by matching argument names to upstream asset names feels too magical for your tastes, you can also define dependencies in a more explicit way:

```python file=/concepts/assets/explicit_string_asset_dependency.py
from dagster import AssetIn, asset


@asset
def upstream_asset():
    return [1, 2, 3]


@asset(ins={"upstream": AssetIn("upstream_asset")})
def downstream_asset(upstream):
    return upstream + [4]
```

In this case, `ins={"upstream": AssetIn("upstream_asset")}` declares that the contents of the asset with the key `upstream_asset` will be provided to the function argument named `upstream`.

Asset keys can also be provided to <PyObject object="AssetIn" /> to explicitly identify the asset. For example:

```python file=/concepts/assets/explicit_asset_dependency_asset_keys.py
from dagster import AssetIn, asset


# If the upstream key has a single segment, you can specify it with a string:
@asset(ins={"upstream": AssetIn(key="upstream_asset")})
def downstream_asset(upstream):
    return upstream + [4]


# If it has multiple segments, you can provide a list:
@asset(ins={"upstream": AssetIn(key=["some_db_schema", "upstream_asset"])})
def another_downstream_asset(upstream):
    return upstream + [10]
```

---

## External asset dependencies

TODO: Add description. Consider linking to the external assets documentation here.

---

## What's next?

---

## Related
