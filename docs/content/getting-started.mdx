# Getting Started with Dagster

## What's Dagster?

Dagster is a system for building and maintaining data assets, such as tables, data sets, machine learning models, or reports.

With Dagster, you declare the assets that you want to exist, the dependencies between them, and how they should be updated.  Dagster then takes responsibility for keeping your assets up-to-date, as well as for tracking their history.

For example, you might say “The recommendations table is derived by applying a function to the users table, the items table, and recommender ML model. It should be updated hourly.”

```python
from dagster import AssetGroup, ScheduleDefinition, asset

@asset(io_manager="snowflake")
def recommendations(users, items, recommender):
    return recommender.predict(users, items)

schedule = ScheduleDefinition(
    job=AssetGroup([recommendations]).build_job(),
    cron_schedule="@hourly",
)
```

Dagster hosts an inspectable, versioned blueprint of the assets that you intend to exist and the history of computations that have mutated those assets.  This can be used to surface discrepancies between your expected assets and the assets that exist in persistent storage. To resolve these discrepancies, Dagster can automatically kick off computations, or you can launch computations manually.


<img src="/images/getting-started/asset-graph.png" />

At Dagster’s core is a general-purpose orchestration engine that allows defining and executing graphs of arbitrary computations. For operations that don’t involve assets, you can program against this orchestrator directly.


```python
from dagster import op, job
from my_utils import all_my_tables, is_bad_table, send_slack_message

@op
def find_bad_tables() -> list[str]:
    return [table for table in all_my_tables if is_bad_table(table)]

@op
def report_bad_tables(bad_tables: list[str]) -> None:
    send_slack_message("The bad tables are:" + ', '.join(bad_tables))

@job
def bad_tables_job():
    report_bad_tables(find_bad_tables())
```

Dagster’s integration libraries make it easy to declare assets that are computed using systems like dbt, Fivetran, Airbyte, and Spark. A graph of Dagster assets can include an ML model built using Python that depends on a table built using dbt that depends on a table ingested using Airbyte. E.g. this code:

```python
from dagster_airbyte import build_airbyte_assets
from dagster_dbt import load_assets_from_dbt_project

airbyte_assets = build_airbyte_assets(
    connection_id=AIRBYTE_CONNECTION_ID, destination_tables=["orders", "users"]
)

dbt_assets = load_assets_from_dbt_project(
    project_dir=DBT_PROJECT_DIR
)

all_together_now = airbyte_assets + dbt_assets
```

Can result in this asset graph:

<img src="/images/getting-started/modern-data-stack-asset-graph.png" />


## Quick Start

### Installing Dagster

To install the latest version of Dagster into an existing Python environment, run:

```bash
pip install dagster
```

### Defining an Asset

...


---

To learn more about Dagster, head over to the [Tutorial](/tutorial). And if you get stuck or have any other questions, we'd love to hear from you on Slack:

<p align="center">
  <a href="https://dagster-slackin.herokuapp.com/" target="_blank">
    <Image
      alt="join-us-on-slack"
      src="/assets/join-us-on-slack.png"
      width="160"
      height="40"
    />
  </a>
</p>
