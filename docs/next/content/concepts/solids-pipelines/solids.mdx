---
title: Solids | Dagster
description:
  Solids are the functional unit of computation in Dagster, and contain the core logic of your
  orchestration graph.
---

# Solids

Solids are the functional unit of work in Dagster. The responsibility of a solid is to read its inputs, perform an action, and optionally emit outputs. Multiple solids can be connected to create a [Pipeline](/concepts/solids-pipelines/pipelines).

<img src="/images/solids.png" />

## Relevant APIs

| Name                                   | Description                                                                                                                                                                                                  |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <PyObject object="solid" decorator />  | The decorator used to define solids. The decorated function is called the `compute_fn`. The decorator returns a <PyObject object="SolidDefinition" />                                                        |
| <PyObject object="InputDefinition" />  | InputDefinitions define the inputs to a solid compute function. These are defined on the `input_defs` argument to the <PyObject object="solid" decorator/> decorator                                         |
| <PyObject object="OutputDefinition" /> | OutputDefinitions define the outputs of a solid compute function. These are defined on the `output_defs` argument to the <PyObject object="solid" displayText="@solid"/> decorator                           |
| <PyObject object="SolidDefinition"  /> | Base class for solids. You almost never want to use initialize this class directly. Instead, you should use the <PyObject object="solid" decorator /> which returns a <PyObject object="SolidDefinition"  /> |

## Overview

Solids are used to organize computation so that they can be tied together to form a [Pipeline](/concepts/solids-pipelines/pipelines). They generally perform one specific action and are used for batch computations. For example, you can use a solid to:

- Execute a database query and store the result
- Initiate a Spark job in a remote cluster
- Query an API data and store the result in a data warehouse
- Send an email or Slack message

Solids have several important properties:

- **Inputs and Outputs**: Solids have defined [inputs and outputs](#inputs-and-outputs), which can be optionally typed. These types are validated at runtime.
- **Configurable:**: Solids can be configured, using a strongly typed [configuration system](#TODO).
- **Dependencies**: Solids inputs can depend on the outputs from other solids. A solid will not execute until all of its inputs have been resolved successfully. The depdendency structure is defined using a [Pipeline](/concepts/solids-pipelines/pipelines)
- **Event Stream**: Solids can emit a stream of structured events, such as These events can be viewed in [Dagit](#TODO), Dagster's UI tool.

Solids are meant to be **individually testable** and **reusable**. Dagster provides several APIs that make it easy to create a library of solids that work across test, staging, and production environments that can be re-used across your codebase.

---

## Defining a solid

To define a solid, use the <PyObject object="solid" decorator /> decorator. The decorated function is called the `compute_fn` and must have `context` as the first argument. The context provides access to important properties and objects, such as [solid configuration](#TODO) and [resources](#TODO)

```python file=/overview/solids_pipelines/solid_definition.py startafter=start_solid_definition_marker_0 endbefore=end_solid_definition_marker_0
@solid
def my_solid(context):
    return 1
```

### Inputs and Outputs

Each solid defines a set of inputs and outputs using <PyObject object="InputDefinition" pluralize/> and <PyObject object="OutputDefinition" pluralize/>. Inputs and outputs are used to define dependencies between solids.

Both definitions have a few important properties:

- They are named
- They are optionally typed. These types are validated at runtime.
- (Advanced) They can be linked to an <PyObject object="IOManager"/>. See [IOManager](...) for more info.

### Inputs

Inputs are passed as arguments to a solid's `compute_fn`. They are specified using <PyObject object="InputDefinition" displayText="InputDefinitions" />. The value of an input can be passed from the output of another solid, or stubbed (hardcoded) using config.

A solid only executes once all of its inputs have been resolved. This means for every input, the upstream outputs it depends on have been successfully created, or the input was stubbed.

```python
# The name is required, but both dagster_type and description are optional.
# - The dagster type will be checked at runtime
# - The description useful for documentation and is displayed in Dagit

InputDefinition(name="abc", dagster_type=str, description="Some description")
InputDefinition(name="xyz", dagster_type=int, description="Some description")
```

We define input definitions on the <PyObject object="solid" decorator /> decorator. The argument names of the `compute_fn` must match the <PyObject object="InputDefinition" displayText="InputDefinitions" /> names.

```python
# Inputs abc and xyz must appear in the same order on the compute fn
@solid(
    input_defs=[
        InputDefinition(name="abc", dagster_type=str, description="Some description"),
        InputDefinition(name="xyz", dagster_type=int, description="Some description")
    ]
)
def my_input_example_solid(context, abc, xyz):
    pass
```

For simple cases, you can use Python typehints instead of specifying InputDefinitions. However, this will prevent you from being able to set a default value or description for your input.

```python
@solid
def my_typehints_solid(context, abc: str, xyz: int):
    pass
```

### Outputs

Outputs are yielded from a solid's `compute_fn`. When you have one output, you can simply return the output value. When you have more than one output, however, you must use `yield` using the <PyObject object="Output"/> class to disambiguate between outputs.

Similar to <PyObject object="InputDefinition" displayText="InputDefinitions" />, we define <PyObject object="OuputDefinition" displayText="OutputDefinitions" /> on the <PyObject object="solid" decorator /> decorator.

```python file=/legacy/how_tos/solids.py startafter=my_input_output_example_solid_start endbefore=my_input_output_example_solid_end
@solid(
    input_defs=[
        InputDefinition(name="a", dagster_type=int),
        InputDefinition(name="b", dagster_type=int),
    ],
    output_defs=[
        OutputDefinition(name="sum", dagster_type=int),
        OutputDefinition(name="difference", dagster_type=int),
    ],
)
def my_input_output_example_solid(context, a, b):
    yield Output(a + b, output_name="sum")
    yield Output(a - b, output_name="difference")
```

## Using a solid

Solids are used within a <PyObject object="pipeline" displayText="@pipeline" />. You can see more information on the [Pipelines](...) page. You can also execute a single solid, usually within a test context, using the <PyObject object="execute_solid" /> function. More information can be found at [Testing Pipelines and Solids](...)

## Examples

### With inputs

```python
@solid(input_defs=[...])
def addder(_context, value_a, value_b):
  return value_a + value_b
```

### With multiple outputs

Here we have a solid that emits multiple outputs. Notice how we have to use `yield` here instead of return since we more than one output. It is also imporant to wrap the output in the `Output` class, in order to help differentiate different outputs.

```python
@solid(input_defs=[...])
def addder(_context, value_a, value_b):
  return value_a + value_b
```

## Patterns

The way we tell Dagster that one solid should execute after another solid is by declaring that one of the inputs of the former solid depends on one of the outputs of the latter solid. If the former solid doesn't depend on something produced by the latter solid, it theoretically shouldn't need to execute after it.

However, sometimes it doesn't make sense to use Dagster's inputs/outputs to model the dependency. For example, if one solid creates a particular table in a database and another solid consumes that table, then the data is flowing through the database, not through inputs and outputs defined in Dagster.

In this situation, we can use the Nothing Dagster type to model the dependency between the two solids. We are passing "nothing" via Dagster between the two solids. By hooking up a "nothing" output of the first solid to a "nothing" input of the second solid, Dagster understands that the second should execute after the first.

```python
@solid
def create_table_1(_) -> Nothing:
    get_database_connection().execute("create table_1 as select * from some_source_table")


@solid(input_defs=[InputDefinition("start", Nothing)])
def create_table_2(_):
    get_database_connection().execute("create table_2 as select * from table_1")


@pipeline
def my_pipeline():
    create_table_2(create_table_1())
```

### Solid Factory

You may find the need to create utilities that help generate solids. In most cases, you should parameterize solid behavior by adding solid configuration. You should reach for this pattern if you find yourself needing to vary the arguments to the <PyObject object="solid" decorator /> decorator or <PyObject object="SolidDefinition"/> themselves, since they cannot be modified based on solid configuration.

To create a solid factory, you define a function that returns a <PyObject object="SolidDefinition"/> , either directly or by decorating a function with the solid dectorator.

```python
def x_solid(
    arg, name="default_name", input_defs=None, **kwargs,
):
    """
    Args:
        args (any): One or more arguments used to generate the nwe solid
        name (str): The name of the new solid.
        input_defs (list[InputDefinition]): Any input definitions for the new solid. Default: None.

    Returns:
        function: The new solid.
    """

    @solid(name=name, input_defs=input_defs or [InputDefinition("start", Nothing)], **kwargs)
    def _x_solid(context):
        # Solid logic here
        pass

    return _x_solid
```
